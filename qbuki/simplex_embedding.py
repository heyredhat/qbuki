# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/SimplexEmbedding.ipynb.

# %% auto 0
__all__ = ['quick_plot_3d_pts', 'hilbert_to_gpt', 'example1_gpt', 'example2_gpt', 'boxworld_gpt', 'rand_classical_gpt',
           'rand_quantum_gpt', 'sic_gpt', 'mub_gpt', 'polygonal_states', 'dualize_states', 'polygonal_gpt', 'tinyfier',
           'bloch_transform', 'interior_point', 'dualize_effects', 'simplicial_embedding']

# %% ../nbs/SimplexEmbedding.ipynb 7
import matplotlib.pyplot as plt

def quick_plot_3d_pts(*P):
    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    c = ["r", "g", "b", "y"]
    for i, p in enumerate(P):
        ax.scatter(p[0], p[1], p[2], c=c[i])
    ax.scatter(0,0,0,c="black")
    plt.show()

# %% ../nbs/SimplexEmbedding.ipynb 30
from . import gellmann_basis

# Here we use Gellmann matrices to convert quantum states and effects into Bloch vectors.
def hilbert_to_gpt(states, effects):
    d = states[0].shape[0]
    basis = gellmann_basis(d)
    to_gellmann = lambda O: np.array([(O@b).trace() for b in basis[::-1]])
    from_gellman = lambda o: sum([c*basis[d**2-i] for i, c in enumerate(o)])
    return np.array([to_gellmann(o, basis) for o in states]).T.real,\
           np.array([to_gellmann(o, basis) for o in effects]).real,\
                     to_gellmann(np.eye(d), basis).real,\
                     to_gellmann(np.eye(d)/d, basis).real

# %% ../nbs/SimplexEmbedding.ipynb 31
def example1_gpt():
    Zup, Zdown = np.array([1,0]), np.array([0,1])
    Xup, Xdown = np.array([1,1])/np.sqrt(2), np.array([1,-1])/np.sqrt(2)
    s = [np.outer(s, s.conj()) for s in [Zup, Zdown, Xup, Xdown]]
    e = [_/2 for _ in s]
    return hilbert_to_gpt(s, e)

# %% ../nbs/SimplexEmbedding.ipynb 32
def example2_gpt():
    return np.array([[1,0,0,0],\
                     [0,1,0,0],\
                     [0,0,1,0],\
                     [0,0,0,1]]),\
           np.array([[1,1,0,0],
                     [0,1,1,0],\
                     [0,0,1,1],\
                     [1,0,0,1]])/2,\
           np.array([1,1,1,1]),\
           np.mean(S, axis=1)

# %% ../nbs/SimplexEmbedding.ipynb 33
def boxworld_gpt():
    return np.array([[1,1,0],\
                     [1,0,1],\
                     [1,-1,0],\
                     [1,0,-1]]).T,\
           np.array([[1,-1,-1],\
                     [1,1,-1],\
                     [1,1,1],\
                     [1,-1,1]])/4,\
           np.array([1,0,0]),\
           np.array([1,0,0])

# %% ../nbs/SimplexEmbedding.ipynb 34
from . import rand_stochastic 

def rand_classical_gpt(n, r):
    E,S = rand_stochastic(n, r), rand_stochastic(r, n)
    return S, E, np.ones(r), np.ones(r)/r

# %% ../nbs/SimplexEmbedding.ipynb 35
from . import rand_povm, rand_dm

def rand_quantum_gpt(d, n):
    return hilbert_to_gpt([rand_dm(d) for i in range(n)], rand_povm(d,n))

# %% ../nbs/SimplexEmbedding.ipynb 36
from . import sic_povm

def sic_gpt(d):
    return hilbert_to_gpt([e/e.trace() for e in sic_povm(d)], sic_povm(d))

# %% ../nbs/SimplexEmbedding.ipynb 37
from . import prime_mubs

def mub_gpt(d):
    mubs = prime_mubs(d)
    mub_vecs = [v for mub in mubs for v in mub]
    S = [np.outer(v, v.conj()) for v in mub_vecs]
    E = [s/len(mubs) for s in S]
    return hilbert_to_gpt(S, E)

# %% ../nbs/SimplexEmbedding.ipynb 38
def polygonal_states(n):
    w = np.exp(2*np.pi*1j/n)
    return np.array([[1, (w**i).real, (w**i).imag] for i in range(n)]).T

def dualize_states(S, backend="qhull"):
    if backend == "qhull":
        if S.shape[0] == 2:
            return np.array([[-np.min(S[1:]), 1],[np.max(S[1:]), -1]])
        hull = sc.spatial.ConvexHull(S.T[:,1:])
        eq = hull.equations
        A, b = eq[:,:-1], eq[:, -1]
        w = b/S[0,hull.vertices]
        return -np.hstack([w.reshape(w.shape[0],1), A])
    elif backend == "cdd":
        C = cdd.Matrix(S.T, number_type="float")
        C.rep_type = cdd.RepType.GENERATOR
        return np.array(cdd.Polyhedron(C).get_inequalities())

def polygonal_gpt(n):
    S = polygonal_states(n)
    e = dualize_states(S)
    E = e/np.sum(e, axis=0)[0]
    return S, E, np.eye(3)[0], np.eye(3)[0]

# %% ../nbs/SimplexEmbedding.ipynb 44
def tinyfier(X):
    U, D, V = np.linalg.svd(X)
    r = np.isclose(D, 0).argmax(axis=0)
    return U[:,:r if r != 0 else D.shape[0]].T

# %% ../nbs/SimplexEmbedding.ipynb 49
def bloch_transform(I, S):
    Iproj = np.outer(I,I)/(I@I)
    notIproj = np.eye(I.shape[0]) - Iproj
    U, D, V = np.linalg.svd(notIproj @ S)
    r = np.isclose(D, 0).argmax(axis=0)
    return np.vstack([I, (U[:,:r if r != 0 else D.shape[0]].T) @ notIproj])

# %% ../nbs/SimplexEmbedding.ipynb 62
def dualize_states(S, backend="qhull"):
    if backend == "qhull":
        if S.shape[0] == 2:
            return np.array([[-np.min(S[1:]), 1],[np.max(S[1:]), -1]])
        hull = sc.spatial.ConvexHull(S.T[:,1:])
        eq = hull.equations
        A, b = eq[:,:-1], eq[:, -1]
        return -np.hstack([b.reshape(-1,1), A])
    elif backend == "cdd":
        C = cdd.Matrix(S.T, number_type="float")
        C.rep_type = cdd.RepType.GENERATOR
        return np.array(cdd.Polyhedron(C).get_inequalities())

# %% ../nbs/SimplexEmbedding.ipynb 68
def interior_point(halfspaces):
    #https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.HalfspaceIntersection.html
    norm_vector = np.reshape(np.linalg.norm(halfspaces[:, :-1], axis=1), (halfspaces.shape[0], 1))
    c = np.zeros((halfspaces.shape[1],)); c[-1] = -1
    A = np.hstack((halfspaces[:, :-1], norm_vector))
    b = -halfspaces[:, -1:]
    res = sc.optimize.linprog(c, A_ub=A, b_ub=b, bounds=(None, None))
    return res.x[:-1]

def dualize_effects(E, backend="qhull"):
    if backend == "qhull":
        if E.shape[1] == 2:
            b, a = E[:,0], E[:,1]
            greater = [-b[i]/a[i] for i in range(len(a)) if a[i] > 0]
            less = [-b[i]/a[i] for i in range(len(a)) if a[i] < 0]
            return np.array([[1, np.max(greater)] if len(greater) != 0 else [0,-1],\
                             [1, np.min(less)] if len(less) != 0 else [0,1]]).T
        hs = np.roll(-E, -1, axis=1)
        half = sc.spatial.HalfspaceIntersection(hs, interior_point(hs))
        intersections = half.intersections.T
        return np.vstack([np.ones((1, intersections.shape[1])), intersections])
    elif backend == "cdd":
        C = cdd.Matrix(E, number_type="float")
        C.rep_type = cdd.RepType.INEQUALITY
        return np.array(cdd.Polyhedron(C).get_generators()).T

# %% ../nbs/SimplexEmbedding.ipynb 79
def simplicial_embedding(S, E, IA, MA):
    p_, Phi_ = cp.Variable(nonneg=True),\
               cp.Variable(shape=(S.shape[1], E.shape[0]), nonneg=True)
    problem = cp.Problem(cp.Minimize(p_),\
               [p_*MA + (1-p_)*IA - S @ Phi_ @ E == 0])
    problem.solve()
    return p_.value, Phi_.value
